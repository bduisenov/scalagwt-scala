/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2002-2008, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */

// $Id: RemoveNonJavaExpressions.scala 15515 2008-07-09 15:30:59Z spoon $

package scala.tools.nsc.backend.jvm
import scala.collection.mutable.ListBuffer
import scala.tools.nsc.transform.Transform
import scala.tools.nsc.symtab.SymbolTable
import scala.tools.nsc.util.Position

/**
 * Several expressions in Scala can only be statements in Java.  This
 * transform rewrites method bodies with such expressions whenever they
 * appear in an expression context.  For example, arguments to
 * method calls are in an expression context, but the statements of
 * a block are not in an expression context.
 * 
 * In addition, this transform does the following normalizations:
 * <ul>
 * <li> All methods that don't return Unit get an explicit return
 * <li> Expressions in statement position that Java disallows as
 *      statements are discarded.  Examples are literals,
 *      field selections, and <code>this</code>.  TODO(spoon): check that field selects are safe to drop; the instance can have a side effect!
 * <li> All thrown, checked exceptions are hidden from Java using
 *      <code>JavaSourceMisc.hiddenThrow()</code>.
 * <li> Many expressions are made to be a block if they aren't already:
 *      the body of a LabelDef, the three subexpressions of
 *      a try-catch-finally expression, the two branches of any
 *      if expression appearing as a statement in a block, the
 *      rhs of a DefDef.
 * <li> The expression of any block is simply a unit constant.
 *      Thus, after this phase, blocks are only used for
 *      side effects.
 * <li> Replace box and unbox operations by calls into the Scala
 *      runtime.
 * </ul>
 * 
 * TODO(spoon): in constructor calls within a constructor, the extracted
 * code needs to be moved to a method in some top-level object, because the
 * Java compiler will not allow any statements to precede the constructor call.
 */
trait NormalizeForJavaSource
extends Transform
with JavaDefinitions
with JavaSourceAnalysis
with JavaSourceNormalization
{
  val global: Global
  import global._
  import global.definitions._
  import global.gen.mkAttributedIdent
  import javaDefinitions._

  override val phaseName = "normjvmsrc"
  
  override protected def newTransformer(unit: CompilationUnit): Transformer =
    new Trans(unit)
  
  /**
   * The main transformer of this phase.
   */
  private class Trans(cunit: CompilationUnit) extends Transformer {
    /** A list of statements that need to be inserted at the
     *  nearest enclosing block. */
    var newStats = new ListBuffer[Tree]
    
    /**
     * The nearest enclosing method.
     */
    var currentMethodSym: Symbol = NoSymbol
    
    def allocLocal(tpe: Type, pos: Position): Symbol = {
      assert (tpe != UnitClass.tpe) // don't create a unit variable
      assert (tpe != null)
      val newLocal = currentMethodSym.newValue(pos, cunit.fresh.newName())
      newLocal.setInfo(tpe)
      newLocal
    }
    
    /**
     * Transform a tree into a list of statements followed by a new tree.
     * In all of the resulting trees, the only place a non-Java expression appears
     * is in a statement context.  If <code>isStat</code> is true,
     * the final tree is considered to be in a statement context.
     */
    def removeNonJavaExpressions(tree: Tree, isStat: Boolean): (List[Tree], Tree) =
      newStatsAndValue { if (isStat) transformStatement(tree) else transform(tree) }

    /**
     * Transform a list of Scala expressions into a list of Java statements 
     * followed by a list of Java expressions.  The list of Java expressions
     * will be the same length as the original list of trees, and evaluating 
     * one of them will give the same value as the original Scala expression.
     */
    def removeNonJavaExpressions(trees: List[Tree]): (List[Tree], List[Tree]) =
      newStatsAndValue { transformTrees(trees) }
      
    /**
     * Run an expresison, and return a tuple of the new statements generated by running
     * the expression along with the result of the expression.
     */
    def newStatsAndValue[T](exp: => T): (List[Tree], T) = {
      val savedNewStats = newStats
      newStats = new ListBuffer
      val result = exp
      val treeNewStats = newStats.toList
      newStats = savedNewStats
      (treeNewStats, result)
    }
    
    
    
    /**
     * Transform a list of trees, assuming none is in statement
     * position.  Preserve order of evaluation.
     */
    override def transformTrees(trees: List[Tree]): List[Tree] = {
      val transformedWithStats: List[(List[Tree], Tree)] = 
        trees.map(removeNonJavaExpressions(_, false))
      
      val lastWithStats = transformedWithStats.findLastIndexOf{
        case (stats, exp) => !stats.isEmpty
      }
      if (lastWithStats < 0) {
        // none of the trees needed special treatment
        transformedWithStats.map{case (stats, exp) => exp}
      } else {
        // To preserve order of evaluation, all expressions up through
        // lastWithStats must be put in local variables
        val (toExtract, toLeaveAlone) = transformedWithStats.splitAt(lastWithStats)
        val resultExps = new ListBuffer[Tree]
        for ((stats, exp) <- toExtract) {
          newStats ++= stats
          if (exp.tpe.isInstanceOf[MethodType]) {
            // Don't try to save a method to a val!
            // TODO(spoon): also skip the val for stable, side-effect-free expressions like literals
            resultExps += exp
          } else {
            if (isUnit(exp.tpe)) {
              newStats += exp
              resultExps += unitLiteral
            } else {
              val newLocal = allocLocal(exp.tpe, exp.pos)
              val newValDef = ValDef(newLocal, exp)
              newStats += newValDef
              resultExps += (mkAttributedIdent(newLocal) setType exp.tpe)
            }
          }
        }
        for ((stats, exp) <- toLeaveAlone) {
          newStats ++= stats // the first one in toLeaveAlone does not need
                             // a val, but it can have statements
          resultExps += exp
        }
        resultExps.toList
      }
    }
    
    /**
     * Transform a tree that is known to be used in statement position.
     */
    def transformStatement(tree: Tree): Tree =
      tree match {
        case If(cond, exp1, exp2) =>
          val condT = transform(cond)
          val exp1T = transformStatement(explicitBlock(exp1))
          val exp2T = transformStatement(explicitBlock(exp2))
          copy.If(tree, condT, exp1T, exp2T)
        case Block(stats, exp) =>
          val newBlockStats = new ListBuffer[Tree]
          for (stat <- stats) {
            val (statNewStats, statT) = removeNonJavaExpressions(stat, true)
            newBlockStats ++= statNewStats
            if (canBeStatement(statT)) {
              // The only non-statement expressions also have no side
              // effects, so they can safely be discarded
              newBlockStats += statT
            }
          }
          val (expNewStats, expT) = removeNonJavaExpressions(exp, false)
          newBlockStats ++= expNewStats
          if (canBeStatement(expT))
            newBlockStats += expT
          copy.Block(tree, newBlockStats.toList, unitLiteral)
        case ValDef(mods, name, tpt, rhs) =>
          copy.ValDef(tree, mods, name, tpt, transform(rhs))
	    case LabelDef(name, params, rhs) =>
	      copy.LabelDef(tree, name, params, transformStatement(explicitBlock(rhs)))
        case Try(block, catches, finalizer) =>
          val blockT = transformStatement(explicitBlock(block))
          val catchesT = catches map (transform(_).asInstanceOf[CaseDef])
          val finalizerT = transformStatement(explicitBlock(finalizer))
          copy.Try(tree, blockT, catchesT, finalizerT)
        case tree =>
          transform(tree)
      }

    /**
     * Transform a tree to a new tree that does not use any non-Java expressions
     * in an expression context.  As a side effect, add statements to <code>newStats</code>
     * whose execution should precede that of the returned tree.  The <code>tree</code>
     * passed as an argument is assumed to be in an expression context.
     * 
     * TODO(spoon): alphabetize the cases
     */
    override def transform(tree: Tree): Tree =
      tree match {
        case tree@CaseDef(pat, guard, body) =>
          CaseDef(pat, guard, transformStatement(explicitBlock(body)))
	    case tree@DefDef(mods, name, tparams, vparamss, tpt, rhs) =>
          val savedMethodSym = currentMethodSym
          currentMethodSym = tree.symbol
          val rhsHiddenExceptions = if (isConstructor(tree)) rhs else hideExceptions(rhs)
          // TODO(spoon): handle constructors
          val res = copy.DefDef(tree, mods, name, tparams, vparamss, tpt, 
                                transformStatement(explicitBlockWithReturn(rhsHiddenExceptions)))
          currentMethodSym = savedMethodSym
          res
        case tree@LabelDef(name, params, rhs) =>
          assert (params == Nil)
          // TODO(spoon): investigate whether the params can be non-empty at this phase
          if (isUnit(rhs.tpe)) {
            newStats += transformStatement(tree)
            unitLiteral
          } else {
            val resultLocal = allocLocal(rhs.tpe, tree.pos)
            newStats += transformStatement(
              LabelDef(name, Nil, 
                       Assign(mkAttributedIdent(resultLocal), rhs) setType rhs.tpe) copyAttrs tree)
            mkAttributedIdent(resultLocal) setPos tree.pos
          }

	    case Block(stats, expr) =>
           for (stat <- stats) {
             newStats += transformStatement(stat)
           }
           transform(expr)
	    case If(cond, exp1, exp2) =>
	      val condT = transform(cond)
          val (branchStats, List(condTT, exp1T, exp2T)) = removeNonJavaExpressions(List(condT, exp1, exp2))
          if (branchStats.isEmpty && !isNothing(exp1T) && !isNothing(exp2T)) {
            If(condTT, exp1T, exp2T) setType tree.tpe setPos tree.pos
          } else {
            // If either branch needs statements, or if either branch is
            // of type nothing, then it is necessary to
            // make a top-level if
            if (isUnit(tree.tpe)) {
              newStats += transformStatement(
                If(condT, exp1, exp2) setType tree.tpe)
              unitLiteral
            } else {
              val resV = allocLocal(tree.tpe, tree.pos)
              newStats += ValDef(resV)
              def statForBranch(branch: Tree) =
                if (isNothing(branch)) branch else {
                  Assign(mkAttributedIdent(resV), branch) setType branch.tpe  // TODO(spoon): should be type unit?
                }
              newStats += transformStatement(
                If(condT, statForBranch(exp1), statForBranch(exp2)) setType tree.tpe)
              mkAttributedIdent(resV)
            }
          }
        case tree@Try(block, catches, finalizer) =>
          if (isUnit(tree.tpe)) {
            newStats += transformStatement(tree)
            unitLiteral
          } else {
            val resV = allocLocal(tree.tpe, tree.pos)
            newStats += ValDef(resV)
            
            val newBlock =
              if (isUnitOrNothing(block)) block 
              else Assign(mkAttributedIdent(resV), block) setType definitions.UnitClass.tpe
            
            val newCatches =
              for (CaseDef(pat, guard, body) <- catches)
              yield 
                if (isUnitOrNothing(body)) CaseDef(pat, guard, body)
                else CaseDef(pat, guard, Assign(mkAttributedIdent(resV), body) setType definitions.UnitClass.tpe)
            newStats += transformStatement(Try(newBlock, newCatches, finalizer) setType tree.tpe)
            mkAttributedIdent(resV)
          }     
        case Apply(fun, List(expr)) if (definitions.isBox(fun.symbol)) =>
          transform(box(fun.symbol, expr))
        case Apply(fun, List(expr)) if (definitions.isUnbox(fun.symbol)) =>
          transform(unbox(fun.symbol, expr))
	    case Apply(fun, args) =>
          val funT :: argsT = transformTrees(fun :: args)
          copy.Apply(tree, funT, argsT)
        case tree => super.transform(tree)
      }
  }
}
