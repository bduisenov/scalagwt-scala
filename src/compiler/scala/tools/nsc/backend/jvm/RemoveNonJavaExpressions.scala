/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2002-2008, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */

// $Id$

package scala.tools.nsc.backend.jvm
import scala.collection.mutable.ListBuffer
import scala.tools.nsc.transform.Transform
import scala.tools.nsc.symtab.SymbolTable
import scala.tools.nsc.util.Position

/**
 * Several expressions in Scala can only be statements in Java.  This
 * transform rewrites method bodies with such expressions whenever they
 * appear in an expression context.  For example, arguments to
 * method calls are in an expression context, but the statements of
 * a block are not in an expression context.
 * 
 * In addition, this transform does the following normalizations:
 * <ul>
 * <li> All methods that don't return Unit get an explicit return
 * <li> Expressions in statement position that Java disallows as
 *      statements are discarded.  Examples are literals,
 *      field selections, and <code>this</code>.
 * <li> Many expressions are made to be a block if they aren't already:
 *      the body of a LabelDef, the three subexpressions of
 *      a try-catch-finally expression, the two branches of any
 *      if expression appearing as a statement in a block.
 * <li> The expression of any block is simply a unit constant.
 *      
 * </ul>
 * 
 * TODO(spoon): in constructor calls within a constructor, the extracted
 * code needs to be moved to a method in some top-level object, because the
 * Java compiler will not allow any statements to precede the constructor call.
 * 
 * TODO(spoon): probably need to handle expressions of type Nothing and Unit;
 * for Nothing, substitute a literal depending on the expected type. 
 */
trait RemoveNonJavaExpressions
extends Transform
with JavaDefinitions
with JavaSourceAnalysis
with JavaSourceNormalization
{
  val global: Global
  import global._
  import javaDefinitions._
  import definitions._

  override val phaseName = "nonjavaexps"
  
  override protected def newTransformer(unit: CompilationUnit): Transformer =
    new Trans(unit)
  
  /**
   * Rewrite a tree to be a sequence of statements followed by a single expression.
   */
  private class Trans(cunit: CompilationUnit) extends Transformer {
    /** A list of statements that need to be inserted at the
     *  nearest enclosing block. */
    var newStats = new ListBuffer[Tree]
    
    /**
     * The nearest enclosing method.
     */
    var currentMethodSym: Symbol = NoSymbol    

    def allocLocal(tpe: Type, pos: Position): Symbol = {
      val newLocal = currentMethodSym.newValue(pos, cunit.fresh.newName())
      newLocal.setInfo(if(tpe == null) UnitClass.tpe else tpe)
      newLocal
    }
    
    /**
     * Transform a tree into a list of statements followed by a new tree.
     * In all of the resulting trees, the only place a non-Java expression appears
     * is in a statement context.  If <code>isStat</code> is true,
     * the final tree is considered to be in a statement context.
     */
    def removeNonJavaExpressions(tree: Tree, isStat: Boolean): (List[Tree], Tree) =
      newStatsAndValue { if (isStat) transformStatement(tree) else transform(tree) }

    /**
     * Transform a list of Scala expressions into a list of Java statements 
     * followed by a list of Java expressions.  The list of Java expressions
     * will be the same length as the original list of trees, and evaluating 
     * one of them will give the same value as the original Scala expression.
     */
    def removeNonJavaExpressions(trees: List[Tree]): (List[Tree], List[Tree]) =
      newStatsAndValue { transformTrees(trees) }
      
    /**
     * Run an expresison, and return a tuple of the new statements generated by running
     * the expression along with the result of the expression.
     */
    def newStatsAndValue[T](exp: => T): (List[Tree], T) = {
      val savedNewStats = newStats
      newStats = new ListBuffer
      val result = exp
      val treeNewStats = newStats.toList
      newStats = savedNewStats
      (treeNewStats, result)
    }
    
    
    
    /**
     * Transform a list of trees, assuming none is in statement
     * position.  Preserve order of evaluation.
     */
    override def transformTrees(trees: List[Tree]): List[Tree] = {
      val transformedWithStats: List[(List[Tree], Tree)] = 
        trees.map(removeNonJavaExpressions(_, false))
      
      val lastWithStats = transformedWithStats.findLastIndexOf{
        case (stats, exp) => !stats.isEmpty
      }
      if (lastWithStats < 0) {
        // none of the trees needed special treatment
        transformedWithStats.map{case (stats, exp) => exp}
      } else {
        // To preserve order of evaluation, all expressions up through
        // lastWithStats must be put in local variables
        val (toExtract, toLeaveAlone) = transformedWithStats.splitAt(lastWithStats)
        val resultExps = new ListBuffer[Tree]
        for ((stats, exp) <- toExtract) {
          newStats ++= stats
          if (exp.tpe.isInstanceOf[MethodType]) {
            // Don't try to save a method to a val!
            // TODO(spoon): also skip the val for stable, side-effect-free expressions like literals
            resultExps += exp
          } else {
            val newLocal = allocLocal(exp.tpe, exp.pos)
            val newValDef = ValDef(newLocal, exp)
            newStats += newValDef
            resultExps += (Ident(newLocal) setType exp.tpe)
          }
        }
        for ((stats, exp) <- toLeaveAlone) {
          newStats ++= stats // the first one in toLeaveAlone does not need
                             // a val, but it can have statements
          resultExps += exp
        }
        resultExps.toList
      }
    }
    
    /**
     * Transform a tree that is known to be used in statement position.
     */
    def transformStatement(tree: Tree): Tree =
      tree match {
        case If(cond, exp1, exp2) =>
          val condT = transform(cond)
          val exp1T = transformStatement(explicitBlock(exp1))
          val exp2T = transformStatement(explicitBlock(exp2))
          copy.If(tree, condT, exp1T, exp2T)
        case Block(stats, exp) =>
          val newBlockStats = new ListBuffer[Tree]
          for (stat <- stats) {
            val (statNewStats, statT) = removeNonJavaExpressions(stat, true)
            newBlockStats ++= statNewStats
            if (canBeStatement(statT)) {
              // The only non-statement expressions also have no side
              // effects, so they can safely be discarded
              newBlockStats += statT
            }
          }
          val (expNewStats, expT) = removeNonJavaExpressions(exp, false)
          newBlockStats ++= expNewStats
          if (canBeStatement(expT))
            newBlockStats += expT
          copy.Block(tree, newBlockStats.toList, Literal(()))
        case ValDef(mods, name, tpt, rhs) =>
          copy.ValDef(tree, mods, name, tpt, transform(rhs))
	    case LabelDef(name, params, rhs) =>
	      copy.LabelDef(tree, name, params, transformStatement(explicitBlock(rhs)))
        case Try(block, catches, finalizer) =>
          val blockT = transformStatement(explicitBlock(block))
          val catchesT = catches map (transform(_).asInstanceOf[CaseDef])
          val finalizerT = transformStatement(explicitBlock(finalizer))
          copy.Try(tree, blockT, catchesT, finalizerT)
        case tree =>
          transform(tree)
      }

    /**
     * Transform a tree to a new tree that does not use any non-Java expressions
     * in an expression context.  As a side effect, add statements to <code>newStats</code>
     * whose execution should precede that of the returned tree.  The <code>tree</code>
     * passed as an argument is assumed to be in an expression context.
     */
    override def transform(tree: Tree): Tree =
      tree match {
	    case DefDef(mods, name, tparams, vparamss, tpt, rhs) =>
          val savedMethodSym = currentMethodSym
          val res = copy.DefDef(tree, mods, name, tparams, vparamss, tpt, 
                                transformStatement(explicitBlockWithReturn(rhs)))
          currentMethodSym = savedMethodSym
          res
        case tree:LabelDef =>
          newStats += transformStatement(tree)
          Literal(())

	    case Block(stats, expr) =>
           for (stat <- stats) {
             newStats += transformStatement(stat)
           }
           transform(expr)
	    case If(cond, exp1, exp2) =>
	      val condT = transform(cond)
          val (branchStats, List(condTT, exp1T, exp2T)) = removeNonJavaExpressions(List(condT, exp1, exp2))
          if (branchStats.isEmpty) {
            If(condTT, exp1T, exp2T) setType tree.tpe setPos tree.pos
          } else {
            // If either branch needs statements, then it is necessary to
            // make a top-level if
            val resV = allocLocal(tree.tpe, tree.pos)
            newStats += ValDef(resV)
            newStats += transformStatement(If(condT, Assign(Ident(resV), exp1), Assign(Ident(resV), exp2)))
            Ident(resV) setType tree.tpe
          }
        case tree:Try =>
          newStats += transformStatement(tree)
          Literal(()) // TODO(spoon): need to get the actual value computed, just like with if
	    case Apply(fun, args) =>
          val funT :: argsT = transformTrees(fun :: args)
          copy.Apply(tree, funT, argsT)
        case tree => super.transform(tree)
      }
  }
}
